---
description: Backend Integration Rules and Guidelines
globs: src/**/*.ts, src/**/*.js, src/**/*.tsx, pages/api/**/*
alwaysApply: false
---
---
description: Backend Integration Rules and Guidelines
globs: src/**/*.ts, src/**/*.js, src/**/*.tsx, pages/api/**/*
alwaysApply: false
version: 1.1.0
last_updated: 2024-03-02
---
# Backend Integration Rules

## Purpose
This document guides the AI on how to handle backend integration-related requests and documentation updates.

## Documentation Reference
- Implementation patterns are defined in [backend-integration.md](mdc:docs/backend-integration.md)
- API contract consistency is defined in [api-contract-rule.mdc](mdc:stockanalysisgui/.cursor/rules/api-contract-rule.mdc)
- Always refer to both documents before making any changes

## Primary API Endpoints

1. **Market Data Endpoints**
   - `/api/v1/market-data` - Market overview
   - `/api/v1/stock/{symbol}` - Stock details
   - `/api/v1/quarters` - Available quarters

2. **Analysis Endpoints**
   - `/api/v1/stock/{symbol}/analysis-history` - Analysis history
   - `/api/v1/analysis/{analysis_id}` - Analysis content
   - `/api/v1/stock/{symbol}/refresh-analysis` - Generate new analysis

3. **Portfolio Endpoints**
   - `/api/v1/portfolios` - List user portfolios
   - `/api/v1/portfolios/{id}` - Specific portfolio
   - `/api/v1/holdings` - User holdings

4. **Scraper Endpoints**
   - `/api/v1/scraper/scrape` - Trigger scraping
   - `/api/v1/scraper/companies` - List companies
   - `/api/v1/scraper/company/{company_name}` - Get company data
   - `/api/v1/scraper/remove-quarter` - Remove quarter data

## Request Handling Rules

1. **For General Backend Integration Questions**
   ```
   1. Reference backend-integration.md and api-contract-rule.mdc
   2. Provide guidance based on existing patterns
   3. DO NOT modify any code or documentation without permission
   ```

2. **For Change Requests**
   ```
   1. Confirm explicit request for backend system change
   2. Review backend-integration.md for current implementation
   3. Implement requested changes following api-contract-rule.mdc standards
   4. Wait for user to confirm functionality
   5. Only update backend-integration.md after user confirmation
   ```

## Change Implementation Process

1. **When User Requests Changes**
   ```
   ✅ DO:
   - Get explicit confirmation that backend change is needed
   - Implement changes following backend-integration.md patterns
   - Ensure consistency with api-contract-rule.mdc guidelines
   - Test integration points thoroughly
   - Ask user to verify functionality
   - Update docs only after user confirms

   ❌ DON'T:
   - Change API endpoints without user confirmation
   - Modify authentication mechanisms without approval
   - Change data structures without understanding impact
   - Create new endpoints that deviate from patterns
   ```

2. **Best Practices for API Calls**
   ```
   ✅ DO:
   - Use React Query for data fetching
   - Implement proper loading states
   - Handle errors gracefully with user feedback
   - Use TypeScript interfaces for API responses
   - Always parse the response body regardless of status
   - Follow RESTful patterns from documentation

   ❌ DON'T:
   - Use direct fetch without error handling
   - Ignore response types
   - Mix different API calling patterns
   - Handle retries inconsistently
   - Assume response body is available only on successful responses
   ```

## Implementation Examples

1. **Fetching Market Data**
   ```typescript
   // Example pattern for fetching market data
   const fetchMarketData = async (quarter?: string): Promise<MarketDataResponse> => {
     const queryParams = new URLSearchParams();
     if (quarter) queryParams.append('quarter', quarter);
     
     try {
       const response = await fetch(`/api/v1/market-data?${queryParams}`);
       
       // Always parse the response JSON regardless of status
       const data = await response.json();
       
       if (!response.ok) {
         throw new Error(data.message || `Error: ${response.status}`);
       }
       
       return data;
     } catch (error) {
       console.error('Failed to fetch market data:', error);
       throw error;
     }
   };
   ```

2. **React Query Implementation**
   ```typescript
   // Example pattern for React Query implementation
   import { useQuery } from '@tanstack/react-query';
   
   export function useMarketData(quarter?: string) {
     return useQuery({
       queryKey: ['marketData', quarter],
       queryFn: () => fetchMarketData(quarter),
       staleTime: 60 * 60 * 1000, // 1 hour
     });
   }
   ```

3. **API POST Request with Error Handling**
   ```typescript
   // Example of POST request with proper error handling
   const removeQuarterData = async (quarter: string): Promise<RemoveQuarterResponse> => {
     if (!quarter) {
       throw new Error('Quarter parameter is required');
     }
     
     try {
       const response = await fetch('/api/scraper/remove-quarter', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
         },
         body: JSON.stringify({ quarter }),
       });
       
       // Parse the response regardless of status
       const data = await response.json();
       
       // Handle error responses
       if (!response.ok) {
         throw new Error(data.message || `Error ${response.status}`);
       }
       
       return data;
     } catch (error) {
       console.error('Error removing quarter data:', error);
       throw error;
     }
   };
   ```

## NextJS API Routes Implementation

1. **Standard API Route Pattern**
   ```typescript
   // Example of standard NextJS API route implementation
   import { NextResponse } from 'next/server';
   
   export async function POST(request: Request) {
     try {
       // Parse the request body
       const body = await request.json();
       
       // Validate required parameters
       if (!body.required_param) {
         return NextResponse.json(
           { success: false, message: 'Required parameter is missing' },
           { status: 400 }
         );
       }
       
       // Forward the request to the Python backend
       const response = await fetch(`${API_BASE_URL}/endpoint`, {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
         },
         body: JSON.stringify(body),
       });
       
       // Parse the response regardless of status
       const data = await response.json();
       
       // Return appropriate response based on status
       if (!response.ok) {
         return NextResponse.json(
           { 
             success: false, 
             message: data.message || 'Backend error',
           },
           { status: response.status }
         );
       }
       
       // Return successful response
       return NextResponse.json(data);
     } catch (error) {
       console.error('Error in API route:', error);
       return NextResponse.json(
         { 
           success: false, 
           message: error instanceof Error ? error.message : 'An unexpected error occurred',
         },
         { status: 500 }
       );
     }
   }
   ```

## Documentation Update Process

1. Always get user confirmation before updating documentation
2. Ensure any documentation updates match implemented functionality
3. Follow the format and structure of existing documentation
4. Include code examples for new functionality

## Related Rules
- For API contract consistency: See [api-contract-rule.mdc]
- For error handling: See [error-handling-rule.mdc]
- For component lifecycle: See [component-lifecycle-rule.mdc]