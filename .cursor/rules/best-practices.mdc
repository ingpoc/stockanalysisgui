---
description: Best practises
globs: src/**/*.ts, src/**/*.js, src/**/*.tsx
---
React Best Practices:

Use functional components and hooks instead of class components
Implement proper React memo and useMemo for performance
Follow the React hooks rules strictly
Utilize React Context API for global state management
Implement proper error boundaries for graceful error handling

Next.js Standards:

Utilize Next.js App Router for better performance
Implement proper error boundaries
Use proper data fetching patterns with suspense
Leverage Next.js built-in optimizations like code splitting and image optimization
Implement server-side rendering for improved SEO and performance

TypeScript Practices:

Use TypeScript strict mode for better type safety
Follow proper type definitions
Implement comprehensive error handling
Utilize type inference where appropriate to reduce boilerplate
Leverage TypeScript's advanced types like conditional types and mapped types for complex scenarios

Solana Web3.js Best Practices:

Use connection pooling to manage multiple connections efficiently
Implement proper error handling and retries for network requests
Utilize the latest stable version of the Solana JSON RPC API
Implement proper transaction confirmation and error handling
Use the Solana Program Library (SPL) for standard token operations

Wagmi Best Practices:

Implement proper error handling for all hooks
Use the latest stable version of the Ethereum JSON-RPC API
Implement proper chain configuration and switching
Utilize the built-in caching mechanisms for improved performance
Implement proper wallet connection and disconnection handling

React Query Best Practices:

Use proper query keys for caching and refetching
Implement proper error handling and retries
Utilize the built-in caching mechanisms for improved performance
Implement proper query invalidation and refetching strategies
Use the `useMutation` hook for side effects and optimistic updates

React Hook Form Best Practices:

Use the `useForm` hook for form state management
Implement proper validation using the built-in validation system
Utilize the `Controller` component for controlled inputs
Implement proper error handling and display
Use the `useWatch` hook for observing form state changes

Zod Best Practices:

Use Zod for runtime type checking and validation
Implement proper error handling for validation failures
Utilize Zod's built-in transformations for data processing
Implement proper schema definitions for complex data structures
Use Zod's integration with other libraries like React Hook Form for seamless validation

Tailwind CSS Best Practices:

Use utility classes for styling instead of custom CSS
Implement proper responsive design using Tailwind's responsive modifiers
Utilize Tailwind's built-in theming system for consistent design
Implement proper accessibility practices using Tailwind's accessibility classes
Use Tailwind's JIT mode for improved performance and smaller bundle sizes

Recharts Best Practices:

Use proper data structures for chart data
Implement proper responsive design for charts
Utilize Recharts' built-in customization options for consistent design
Implement proper accessibility practices for charts
Use Recharts' built-in animations for improved user experience

General Standards:

Keep components small and focused
Follow proper state management patterns
Use proper code splitting and lazy loading for improved performance
Implement proper security measures like input validation and sanitization
